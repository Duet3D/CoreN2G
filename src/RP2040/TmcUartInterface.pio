; These are the RP2040 PIO programs used to handle TMC driver sigle-wire UART transmission and reception

.program TMC_Tx
.side_set 1 opt

; Transmit program. This reads a word count from the fifo (must be at least 1), then reads that number of 32-bit words from the FIFO and transmits them.

    .wrap_target
    set     pindirs, 0          ; set Tx/Rx pin to input
    pull    block               ; wait for word count, must be at least 1
    mov     y, x                ; copy word count to Y
    set     pins, 1             ; set Tx/Rx pin high
    set     pindirs, 1 [7]      ; set Tx/Rx pin to output
wordloop:
    pull    block               ; get next word to send
byteloop:
    set     x, 7 side 0 [7]     ; init the bit counter and send the start bit
bitloop:
    out     pins, 1             ; send the next bit
    jmp     x--, bitloop [6]    ; loop sending bits
    set     pins, 1 [6]         ; send the stop bit
    jmp     !osre, byteloop     ; loop to send all 4 bytes
    jmp     y--, wordloop       ; loop to send all 32-bit words
    .wrap                       ; set Tx/Rx pin to input and wait for next command

; Receive program. This reads received bytes and pushes complete 32-bit words through the FIFO.

.program TMC_Rx
    .wrap_target
    mov     isr, x              ; clear ISR
    set     y, 4                ; init byte counter
byteloop:
    wait    0 pin, 0            ; wait for start bit
    set     x, 7 [10]           ; init bit counter
bitloop:
    in      pins, 1             ; read the next bit
    jmp     x--, bitloop [6]    ; loop reading bits
    jmp     pin, stopBitOk      ; jump if stop bit seen
    irq     nowait 0            ; signal error
hang:
    jmp     hang
stopBitOk:
    jmp     y--, byteloop
    push    block
    .wrap

; Program to drive WS2812 LEDs, based on the example in the RP2040 datrasheet
; This reads 32-bit words from the FIFO and sends the upper 24 bits to the WS2812 LED string.

.program ws2812
.side_set 1

.define public T1 2
.define public T2 5
.define public T3 3

.wrap_target
bitloop:
    out     x, 1 side 0 [T3 - 1]        ; Side-set still takes place when instruction stalls
    jmp     !x do_zero side 1 [T1 - 1]  ; Branch on the bit we shifted out. Positive pulse
do_one:
    jmp     bitloop side 1 [T2 - 1]     ; Continue driving high, for a long pulse
do_zero:
    nop side 0 [T2 - 1]                 ; Or drive low, for a short pulse
    .wrap

; Total length of all three programs 12 + 11 + 4 = 27 instructions

; End
